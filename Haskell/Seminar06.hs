module Seminar06 where

--------------------------------------------------------------------------------
-- ЯЗЫК HASKELL

-- Haskell - один из самых известных функциональных языков программирования. Он
-- назван в честь американского логика и математика Хаскелла Брукса Карри.

-- Основные особенности языка:
-- * чистая функциональность;
-- * ленивая семантика;
-- * строгая статическая типизация;
-- * вывод типов.

-- Официальный сайт: https://www.haskell.org/.
-- Здесь содержится документация, инструкции по установке и прочая полезная
-- информация.

-- Текущий стандарт языка - Haskell 2010 - также опубликован на этом сайте:
-- https://www.haskell.org/onlinereport/haskell2010/.
-- Первая версия языка была выпущена в 1990-м году.

-- Основной компилятор языка Haskell - это GHC (The Glasgow Haskell Compiler):
-- https://www.haskell.org/ghc/.
-- Он полностью соотвествует стандарту языку и поддерживает ряд расширений.
-- Есть также интерпретатор языка - GHCi (от "interactive"), в котором выражения
-- могут быть вычислены интерактивно. Мы им будем активно пользоваться.

-- HaskellWiki - https://wiki.haskell.org/ - HaskellWiki - вики по языку,
-- поддерживаямая сообществом.

-- Hoogle - https://hoogle.haskell.org/ - поисковая система по функциям и типам,
-- реализованным в языке или библиотеках. Для многих функций есть ссылки на
-- исходный код.

--------------------------------------------------------------------------------
-- КОММЕНТАРИИ

-- Строки, начинающиеся с двух минусов подряд, - это однострочные комментарии.
-- Многострочные комментарии заключены между `{-` и `-}` и выглядят, например,
-- так:

{-
Это
многострочный
комментарий.
-}

--------------------------------------------------------------------------------
-- ЛИТЕРАЛЫ

--'c' -- символ
--"string" -- строка
--True -- логическая константа (также False)
--0 -- целое число (аналогично 1, -4, ...)
--0.0 -- число с плавающей точкой (1e-4, -1E+4, ...)

--------------------------------------------------------------------------------
-- БАЗОВЫЕ ТИПЫ

-- Haskell - типизированный язык со строгой статической проверкой типов. Это
-- означает, что типы проверяются во время компиляции, причем неявные
-- преобразования типов запрещены.

-- Как правило, если выражение построено правильно, компилятор Haskell может
-- самостоятельно вывести тип выражения.

-- Для того, чтобы исследовать типы выражений, можно использовать интепретатор
-- GHCi. Все команды интепретатора начинаются со двоеточия `:`:
-- * :? - вывести все доступные команды;
-- * :type <expr> - вывести тип выражения <expr> (можно сократить до :t).

-- Тип указывается справа от выражения через два двоеточия `::`. Для некоторых
-- выражений определяется конкретный тип:
--'c' :: Char
--False :: Bool
--"string" :: String

--------------------------------------------------------------------------------
-- ЧИСЛОВЫЕ ТИПЫ

-- Но часть выражений может иметь полиморфный тип, удовлетворяющий некоторым
-- ограничениям:
--0 :: Num t => t
-- Читать эту запись нужно так: выражение 4 имеет тип t, являющийся
-- представителем классов типов Num. Часть типа от начала и до стрелки `=>`
-- называется контекстом.

-- Классы типов - специальный механизм, который позволяет указать операции,
-- допустимые для типов. Это позволяет применять одну функцию к экземплярам
-- разных типов, являющимся представителями одного и того же класса типов.
-- Классы типов мы будем подробно изучать на следующих семинарах.

-- Пока что можно воспользоваться еще одной командой интпретатора языка:
-- :info <name> (можно сократить до :i).
-- В нее можно передать имя функции, типа или класса типов, и он выведет
-- некоторую информацию об именованной сущности.

-- Например, если ввести `:i Num`, то можно увидеть список операций,
-- поддерживаемых числовым типом: это (+), (-), (*), abs и другие.

-- Типичным представителем класса типов Num для целых чисел является тип Int.
--1 :: Int
-- Тип Int имеет ограниченную длину и содердит только константы в диапазоне
-- -9223372036854775808..9223372036854775807. Но в языке есть целочисленный тип,
-- реализующий длинную арифметику - это Integer.
--9223372036854775808 :: Integer

--------------------------------------------------------------------------------
-- ТИПЫ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ

-- Если вывести тип числа с плавающей точкой, то получим уже другой контекст:
--0.0 :: Fractional t => t

-- Типичный представитель такого класса типов - это Double (двойная точность) и
-- Float (одинарная).
--2.0 :: Double
--1.0 :: Float

-- Если запросить информацию о классе типов Fractional, то мы увидим, что здесь
-- есть операция (/).

-- Кроме того, в выводе есть строка: `class Num a => Fractional a where`. Это
-- означает, что на каждого представителя a класса типов Fractional наложено
-- ограничение, что он также является предстаивтелем классов типов Num.

-- Значит, является корректным, например, такое выражение
--1 + 0.5 :: Fractional a => a

-- Обе константы имеют полиморфные типы с контектом Num и Fractional, и
-- компилятор вывел, что результат будет иметь тип-представитель класса типов
-- Fractional.

-- Тем не менее, если бы мы указали конкретные типы, Int и Double, то выражение
-- было бы не корректным, так как операция (+) определена над экземплярами
-- одинаковых типов.

-- Используя команду `:i` в интерпретаторе, можно изучать иерархию классов типов
-- и узнавать, какие типы являются представителями каких классов типов.

--------------------------------------------------------------------------------
-- ОБЪЯВЛЕНИЕ КОНСТАНТ

-- Для объявления константы простейшая запись - это имя, знак равенства и
-- выражение.

fourNum = 4 -- имеет тип Num t => t
fiveInt = 5 :: Int -- имеет тип Int

--------------------------------------------------------------------------------
-- ОПЕРАТОРЫ

-- Выражения составляются не только из литералов, но и операторов. Операторы
-- бывают нескольких видов:
-- * арифметические: (+), (-), (*), (/), (^);
-- * сравнения: (==), (/=), (<), (>), (<=), (>=);
-- * логические: (&&), (||).

-- Разумеется, это не полный перечень.

-- Унарный минус - единственный унарный оператор. Логическое отрицание
-- существует только в виде функции not.

-- Пример:
--4 + 10 <= -14 || True

-- Логические операторы действуют по схеме short-circuit evaluation: операнды
-- вычисляются слева направо, но если по левому операнду становится известно
-- значение всего выражения, то правый операнд не вычисляется.

--------------------------------------------------------------------------------
-- ОБЪЯВЛЕНИЕ И ПРИМЕНЕНИЕ ФУНКЦИЙ

-- Функция объявляется так же, как и константа (поскольку является константой),
-- только после имени могут следовать аргументы:
addFour x = x + 4

-- Тип функции записывается в стрелочной нотации: сначала пишутся типы
-- аргументов, затем тип результата. На использованные типы также могут
-- накладываться контексты. Например, тип функции addFour - Num a => a -> a.

-- Стрелка - оператор над типами, она имеет правую ассоциативность. Так, тип
-- Int -> Int -> Int -> Int интерпретируется как Int -> (Int -> (Int -> Int)).

-- Хорошая практика - для top level функций и указывать тип явно а для вложенных
-- опускать (вложенные объявления научимся давать ниже).
sumAndProd :: Int -> Int -> Int -> Int
sumAndProd x y z = x + y * z

-- Теперь для применения функции к аргументам надо после имени функции записать
-- выражения, которые будут подставляться в аргументы.
sixOrEight = sumAndProd 2 2 2

-- Для функций возможно частичное примение, то есть каррирование. Например,
-- выражение (sumAndProd 4) - это функция, которая принимает два аргумента
-- и возвращает их произведение, увеличенное на 2. Мы могли бы записать
-- эту же функцию в следующем виде:
addFourToProd :: Int -> Int -> Int
addFourToProd y z = sumAndProd 4 y z

-- Но частично примененные функции необязательно записывать, перечисляя все
-- аргументы. Если выражение справа - функция, последний аргумент которой
-- совпадает с последним аргументом в объявлении, то этот аргумент можно
-- "сократить" с обеих сторон. Если при этом слева получилась константа, а
-- а справа - функция, то говорят, что функция слева объявлена в бесточечном
-- стиле (point free).
addFourToProdPointFree :: Int -> Int -> Int
addFourToProdPointFree = sumAndProd 4

--------------------------------------------------------------------------------
-- ОБЪЯВЛЕНИЕ СОБСТВЕННЫХ ОПЕРАТОРОВ

-- Haskell не имеет встроенных операторов. Все, что мы видим, объявлено в
-- стандартной библиотеке.

-- Имя операторы может состоят из произвольной последовательности символов:
-- ! # $ % & * + - . / : < = > ? @ \ ^ | ~

-- Все они, за исключением двоеточия, равнозначны. Двоеточие в качестве первого
-- символа оператора означает, что оператор - инфиксный конструктор данных. Эта
-- функциональность будет рассмотрена на следующих семинарах. В середине он
-- работает как обычный символ.

(+-) :: Int -> Int -> Int
(+-) x y = x + (-y)

two :: Int
two = 4 +- 2

-- Приведенные выше определение оператора записано в префиксном стиле. Но можно
-- записать то же самое и в префиксном стиле, тогда запись смотрится более
-- естественно. Аналогичный оператор:
(*-) :: Int -> Int -> Int
x *- y = x * (-y)

-- Естественно в таком случае предположить, что раз операторы можно объявлять
-- в префиксной и инфиксной форме, то можно их и применять в префиксной и
-- инфиксной форме. И это действительно так:
true :: Int -> Int -> Bool
true x y = (x *- y) == ((*-) x y)

-- Более того, функции двух аргументов можно применять в инфиксной форме. Для
-- этого имя функции нужно заключить в обратные кавычки (backquote):
trueTrue x y = (true x y) == (x `true` y)

--------------------------------------------------------------------------------
-- ПРИОРИТЕТ И АССОЦИАТИВНОСТЬ ОПЕРАТОРОВ

-- Каждый оператор имеет свою ассоциативность (fixity) и приоритет (precedence).
-- Приоритет - это целое число от 0 до 9. Сначала применяются операторы с
-- наибольшим приоритетом. Если записано подряд несколько операторов с одним
-- приоритетом - то согласно их ассоциативности, которая бывает правой или
-- левой. Это записывается как infixl и infixr соответственно.

-- Также есть ассоциативность infix, которая означает, что оператор не может
-- участвовать в цепочке применений, например, оператор равенства.

-- Ассоциативность и приоритет можно узнать, вызвав команду `:i` в GHCi.
-- infixl 6 +
-- infixr 7 *
-- infix 4 ==

-- Укажем, например, ассоциативность и приоритет для нашего оператора (+-):
infixl 6 +-
infixr 4 `true`

-- По умолчанию у оператров левая ассоциативность и приоритет 9. В том числе у
-- функций двух аргуметов, записанных в инфиксной форме.

-- Заметим, что одна и та же функция и оператор в инфиксной и префиксной форме
-- имеет разные приоритет: в инфиксной либо тот, который мы указали, либо 9,
-- если не указано. В префиксной форме приоритет всегда 10, то есть применение
-- функции выполняется в первую очередь.

-- Группировать разные части выражений можно с помощью скобок.

--------------------------------------------------------------------------------
-- СЕЧЕНИЯ ОПЕРАТОРОВ

-- Операторы, поскольку они являются функциями, можно каррировать. Однако такая
-- запись не очень удобна, особенно для некоммутативных операторов. Например,
-- когда мы пишем (/) 2, мы, скорее всего, подразумеваем функцию, которая
-- делит двойку, поскольку такая запись читается более естественно. Однако
-- функция (/) 2 принимает число, а возвращает результат деления двойки на это
-- число

-- В Haskell есть особый синтаксис, позволяющий реализовывать так называемые
-- сечения операторов:
half :: Double -> Double
half = (/ 2)
-- Функция выше - правое сечение двойкой оператора (|), то есть функция, которая
-- принимает число и возвращает его половину.

twoOver :: Double -> Double
twoOver = (2 /)
-- Левое сечение симметрично: принимает число и результат деления двойки на это
-- число.

-- Единственное исключение: правое сечение оператором (-). Такого сечения в
-- языке нет, и такая запись читается как отрицательное число: то есть это
-- применение унарного минуса к числу.
minusTwo = (- 2) :: Int

-- Унарного плюса в языке нет, поэтому (+ 2) - функция, прибавляющая к числу 2.

-- Еще одно замечание про унарный минус: чтобы передать отрицательное число
-- в функцию, его нужно заключить в скобки. В противном случае будет ошибка
-- компиляции: например, рассмотрим f :: Int -> Int и выражение f -1. Его нельзя
-- интерпретировать применение функции, потому что после имени функции идет знак
-- минуса, а нужен аргумент. Так что запись парсится как вычитание из f единицы.
-- А так как f - функция, то не проходит проверка типов:
-- (-) :: Num a => a -> a -> a, но мы передаем ей в качестве левого аргумента
-- константу типа Int -> Int. Вот только тип Int -> Int не является
-- представителем класса типов Num.

--------------------------------------------------------------------------------
-- КОРТЕЖИ

-- Кортежем называется упорядоченная последовательность элементов произвольных
-- типов фиксированной длины. В Haskell кортежи пишутся к круглых скобках, а
-- элементы разделяются запятыми. Тип кортежа записывается по той же схеме:
curried :: ((a, b) -> c) -> a -> b -> c
curried f x y = f (x, y)

-- Если кортеж имеет два элемента, то для него доступны две стандартные функции
-- fst и snd, достающие первый и второй элемент кортежа.
tupled :: (a -> b -> c) -> (a, b) -> c
tupled f p = f (fst p) (snd p)

-- Кортеж может быть пустым, в этом случае он записывается как () (кортеж без
-- элементов). Его выглядит точно так же.
emptyTuple = () :: ()

-- Имена констант и функций и имена типов находятся в разных пространствах имен,
-- поэтому коллизии не возникает.

--------------------------------------------------------------------------------
-- СПИСКИ

-- Списком называется упордоченная последовательность элементов фиксированного
-- типа произвольной длины. В Haskell списки пишутся в квадратных скобках, а
-- элементы разделяются запятыми. Тип списка записывается как тип элемента,
-- заключенный в квадратные скобки.
primesBelow10 = [2, 3, 5, 7] :: [Int]

-- Тип [Char] - это ни что иное, как тип String, поэтому при выводе на экран в
-- интерпретаторе он будет отображаться не так, как обычные списки.

-- Самые базовые операции для работы со списками - это добавление элемента в
-- начало списка и конкатенация списков.
prepend :: a -> [a] -> [a]
prepend x xs = x : xs

concatenate :: [a] -> [a] -> [a]
concatenate xs ys = xs ++ ys

-- Пустой список записывается как [] (список без элементов), но тип его
-- элементов - любой
emptyList = [] :: [a]

-- С помощью пустого списка и оператора двоеточия можно перезаписать любой:
primesBelow11 = 2 : 3 : 5 : 7 : []

-- Коснтрукция выше компилируется, так ассоциативность и приоритет - infixr 5 :.

--------------------------------------------------------------------------------
-- УСЛОВНОЕ ВЫРАЖЕНИЕ

-- В императивных языках программирования обычно if - это условный оператор, то
-- есть then- и else-ветви содержат какие-то наборы инструкций. В функциональных
-- языках if - это условное выражение, состоящее из трех выражений:
-- условия, then-выражения и else-выражения.

-- Сначала вычисляется условие, если оно оказалось равно True, то вычисляется
-- then-выражение, и оно возвращается как результат вычисления всего
-- if-выражения, а если False, то наоборот. Второе выражение при этом
-- игнорируется, то есть даже не вычисляется.

-- Отсюда возникают естественные требования, которых нет в императивных языках:
-- * обе ветки должны присутствовать;
-- * оба выражения должны иметь одинаковый тип.

four = if True then 4 else 5
five = if False then 4 else 5

-- Поскольку if - полноценное выражение, его можно использовать как часть
-- более сложного выражения, например:
six = 3 + if 2 + 2 > 5 then 4 else if 2 + 2 > 3 then 3 else 2

--------------------------------------------------------------------------------
-- РЕКУРСИЯ

-- Так как циклы отсутствуют, то в функциональных языках методом итерации
-- является рекурсия.

factorialIf :: Integer -> Integer
factorialIf n = if n == 0 then 1 else n * factorialIf (n - 1)

--------------------------------------------------------------------------------
-- ПРЕРЫВАНИЕ ПРОГРАММЫ

-- В функции factorialIf при передаче на вход в отрицательного числа уйдет
-- в бесконечную рекурсию, и пользователь рано или поздно получит сообщение об
-- ошибке "stack overflow".

-- Более правильно будет сразу выдать ошибку, как только мы обнаружили, что в
-- в функцию передан недопустимый аргумент.

-- Для этого в Haskell существует функция error :: String -> a.
-- Она принимает строку и при вызове завершает программу с ошибкой, в описании
-- которой переданная строка.

-- Формально у функции есть возвращаемое значение ⊥ (bottom). Оно имеет
-- произвольный тип, таким образом, функция везде проходит проверку по типам.

-- Кроме функции error, есть также константа undefined :: a, равная bottom. В
-- этом случае сообщение об ошибке будет иметь текст "Prelude.undefined".

-- Обычно словом undefined помечают недописанные части программы. Это удобно,
-- поскольку bottom проходит проверку типов. Либо undefined используют для
-- частей программы, до которых не может дойти исполнение.

-- Но если исполнение в принципе может дойти до точки, из которой мы не можем
-- корректно вычислить функцию, то лучше вернуть сообщение об ошибке:

factIfUnsafe :: Integer -> Integer
factIfUnsafe n = if n >= 0
                   then factorialIf n
                   else error "`factIfUnsafe n` requires `n >= 0`"

--------------------------------------------------------------------------------
-- СОПОСТАВЛЕНИЕ С ОБРАЗЦОМ

-- Образцами в Haskell могут выступать различные шаблоны, самые базовые из
-- которых литералы, имена, символ подчеркивания и конструкторы типов.
factPM :: Integer -> Integer
factPM 0 = 1
factPM n = n * factPM (n - 1)

-- При каждом применении функции будет происходить сопоставление переданного
-- аргумента с образцами из каждого уравнения сверху вниз до первого совпадения.

-- Если образец - это литерал, то значение аргумента проверяется на равенство.
-- В случае, если равенство выполнено, то возвращается правая часть уравнения.

-- Если образец - это имя, то сопоставление всегда происходит успешно (имя -
-- так называемый неопровержимый образец, irrefutable), причем это имя
-- связывается с аргументом, переданным на вход функции.

-- Если при этом имя образца совпадает с именем, доступным извне, то имя
-- образца перекрывает внешнее.

-- Если образец - это подчеркивание, то сопоставление также всегда успешно (тоже
-- неопровержимый образец), только никакого связывания не происходит, и мы в
-- правой части теряем возможность обратиться к аргументу. Хорошая практика -
-- использовать подчеркивание, если аргумент не используется. Это нередко
-- бывает, когда происходит сопоставление с образцом сразу нескольких
-- аргументов.

-- Если ни один из образцов не подошел, то происходит ошибка с сообщением
-- "Non-exhaustive patterns in function ...".

-- Обратите внимание: даже "обычное" объявление функции можно рассматривать
-- как сопоставление с образцом. Просто в этом случае функция записана через
-- одно уравнение, все образцы - имена, так что сопоставление всегда проходит
-- успешно.

-- Рассмотрим шаблон - конструктор кортежа, который позволяет декомпозировать
-- кортеж на составляющие его элементы. Они могут быть разных типов, их может
-- быть разное количество:
pairMax :: (Int, Int) -> Int
pairMax (x, y) = if x > y then x else y

-- Аналогично существует шаблон для декомпозици списка на голову и хвост,
-- то есть аргументы оператора двоеточия, которые нужно передать, чтобы получить
-- сопоставляемый список
headAndTail :: [a] -> (a, [a])
headAndTail (x : xs) = (x, xs)

-- Если на вход будет передан пустой список, то сопоставления не произойдет.
-- Сопоставление с пустым списком произойдет по шаблону []:
isEmpty :: [a] -> Bool
isEmpty [] = True
isEmpty _  = False

-- Каждому шаблону можнодать псевдоним, по которому к подошедшему подвыражению
-- можно обобращаться в правой части:
duplicateHead :: [a] -> [a]
duplicateHead xs @ (x : _) = x : xs
duplicateHead      _       = []

-- Можно делать сопоставление с образцом нескольких аргументов:
cross :: [a] -> [a] -> [a]
cross (x : xs) (y : ys) = x : y : (cross xs ys)
cross xs       []        = xs
cross _        ys        = ys

--------------------------------------------------------------------------------
-- GUARD EXPRESSION

-- Сопоставление с образцом было бы недостаточно мощным, если бы нельзя было
-- к шаблону добавлять дополнительные условия. Эти условия называются guard
-- expression'ами и записываются через вертикальную черту `|` справа от шаблона.
-- Так можно переписать функцию factorialPM с использованием error:
factPMUnsafe :: Integer -> Integer
factPMUnsafe 0         = 1
factPMUnsafe n | n > 0 = n * factPMUnsafe (n - 1)
factPMUnsafe _         = error "`factorialPMUnsafe n` requires `n >= 0`"

-- Guard-выражение имеет тип Bool и при вычислении должно иметь значение True,
-- чтобы сопоставление прошло успешно.

-- Для одного шаблона можно указывать несколько guard-выражений, тогда они
-- рассматриваются также сверху вниз и ищется первое истинное. Перепишем
-- функцию factorialPMUnsafe таким образом:
factPMUnsafe1 :: Integer -> Integer
factPMUnsafe1 0             = 1
factPMUnsafe1 n | n > 0     = n * factPMUnsafe1 (n - 1)
                | otherwise = error "`factorialPMUnsafe1 n` requires `n >= 0`"

-- Здесь также использовано специальное значение otherwise, которое говорит о
-- о том, что это уравнение должно быть выполнено, если все уравнения выше
-- не подошли - при этом, разумеется, должен подходит шаблон слева!

-- otherwise не какая магическая константа, ее достаточно просто реализовать
-- самостоятельно:
--otherwise = True

--------------------------------------------------------------------------------
-- ВЫРАЖЕНИЕ CASE..OF

-- Сопоставление с образцом возможно не только при объявлении функции, но и в
-- рамках специального выражения case..of: оно позволяет делать сопоставление
-- с образцом справа от знака равенства.

factCaseOf :: Integer -> Integer
factCaseOf n = case n of
    0             -> 1
    _ | n > 0     -> n * factorial (n - 1)
      | otherwise -> error "`factCaseOf n` requires `n >= 0`"

-- На самом деле сопоставление с образцом, рассмотроенное выше, транслируется
-- компиляторов в выражение case..of, то есть записать функции через несколько
-- уравнений - синтаксический сахар для case..of.

-- Более того, даже if - синтаксический сахар для case..of.

--------------------------------------------------------------------------------
-- ХВОСТОВАЯ РЕКУРСИЯ

-- Обычно каждый рекурсивный порождает новый стековый фрейм, поскольку нужно
-- сохранить текущие значения аргументов и констант для использовании после
-- выхода из рекурсивного вызова.

-- Отсюда возникает идея оптимизации: если построить выражение таким образом,
-- что рекурсивный вызов будет последним ("хвост") при вычислении выражения, или
-- даже отсутстовать в терминальном условии, то тогда потребность что-либо
-- сохранять отпадет, а значит, можно для нового рекурсивного вызова взять уже
-- имеющий стековый фрейм.

-- Стандартный прием для сведения рекурсии к хвостовой - использование
-- аккумуляторов.
factorial :: Integer -> Integer
factorial n | n >= 0    = factorialHelper 1 n
            | otherwise = error "`factorial n` requires `n >= 0`"

factorialHelper :: Integer -> Integer -> Integer
factorialHelper acc 0 = acc
factorialHelper acc n = factorialHelper (acc * n) (n - 1)

-- Помимо сокращение расходов на использование памятие, эта техника может
-- и значительно улучшить формальную асимптотику. Рассмотрим наивную реализацию
-- функции вычисления числа Фибоначчи:
fibonacciExp :: Integer -> Integer
fibonacciExp 0             = 0
fibonacciExp 1             = 1
fibonacciExp n | n > 1     = fibonacciExp (n - 1) + fibonacciExp (n - 2)
               | otherwise = error "`fibonacciExp n` requires `n >= 0`"

-- Сложность реализации экспоненциальная. Однако сведение к хвостовой рекурсии с
-- помощью простого аккумулятора позволяет сделать реализовать то же самое за
-- линейную сложность:
fibonacci :: Integer -> Integer
fibonacci n | n >= 0    = fibonacciHelper 0 1 n
            | otherwise = error "`fibonacci n` requires `n >= 0`"

fibonacciHelper :: Integer -> Integer -> Integer -> Integer
fibonacciHelper prev _    0 = prev
fibonacciHelper prev curr n = fibonacciHelper curr (prev + curr) (n - 1)

--------------------------------------------------------------------------------
-- ВЫРАЖЕНИЕ LET..IN

-- В функциях выше плохо, что мы на верхнем уровне определяем функции, которые
-- не имеют осмысленного применения вне данной программы: эти функции играют
-- вспомогательную роль, это часть реализации.

-- Подобные функции не стоит оставлять в коде. Чтобы этого избежать, можно
-- использовать выражение let..in, которое позволяет сделать локальные
-- в рамках одного выражения. Оно имеет следующий синтаксис:
-- let <bindings> in <expression>.

-- Перепишем вычисление факториала с имепользованием let..in:
factorialShort :: Integer -> Integer
factorialShort = let
    helper acc 0 = acc
    helper acc n = helper (acc * n) (n - 1)
  in helper 1

-- Вместо функции может быть также просто коснтанта или даже сопоставление
-- с образцом:
pairSum :: (Int, Int) -> Int
pairSum p = let (x, y) = p in x + y

-- При использовании выражения let..in выжно соблюдать правило отступов: все
-- объявления должны быть выровнены одинаково (в примерах выше одно одно, так
-- что условие выполнено).

-- Вообще, в языке Haskell нет строгих правил расставления отступов, но они
-- влияют на то, как трактуется выражение или объявление. Полные правила
-- описаны в стандарте, понять их сложно, и это не требуется. Общее правило,
-- покрывающее почти все случаи, такого: увеличение отступа безопасно (считается
-- как продолжение объявления из предыдущей строки), а уменьшение может привести
-- к проблемам (если отступ становится меньше того, с которого объявление
-- начиналось).

-- Замечание про отступы: при программировании на Haskell отступы рекомендуется
-- ставить пробелами, поскольку табуляция интерпретирование как 8 пробелов вне
-- зависимости от настроек редактора.

--------------------------------------------------------------------------------
-- КОНСТРУКЦИЯ WHERE

-- Конструкция where призвано выполнять ту же функцию, что и выражение let..in,
-- но здесь сначала пишется выражения, а затем локальные связывания, которые в
-- них могут быть использованы.

-- Важное отличие - конструкция where не является выражением, поэтому следующая
-- коснтрукция некорректна: x ^ x where x = 4.

-- Конструкцию where можно использовать только при объявлении функции, и сделано
-- это затем, чтобы устранить ограничение выражения let..in: в нем все
-- связывания, локальны для одного выражения, а в конструкции where они видны
-- во всей функции, даже если она задана через несколько уравнений.

-- Пример использования where:
fibonacciWhere :: Integer -> Integer
fibonacciWhere n | n >= 0    = helper 0 1 n
                 | otherwise = error "`fibonacci n` requires `n >= 0`"
  where
    helper prev _    0 = prev
    helper prev curr n = helper curr (prev + curr) (n - 1)

-- Для локальных связываний типы обычно не указывают. Как праивило, они понятны,
-- так как в них подставляют либо литералы, типы которых очевидны, либо
-- аргументы внешней функции, типы которых указаны.

--------------------------------------------------------------------------------
-- ИМПОРТЫ

-- Программа на языке Haskell представляет собой набор разных модулей. Главный
-- модуль должен называться Main и содержать функцию main типа IO (), что бы это
-- ни значило. Именна эта функция запускается при исполнении программы.

-- Каждый модуль называется с большой буквы, располагается в отдельном файле,
-- имя котрого совпадает с именем модуля. Например, в текущем файле Seminar06.hs
-- первая строка говорит, что это объявление модуля Seminar06.

-- В каждый модуль неявно импортируется модуль Prelude. Если функция объявлена
-- в другом модуле, то модуль нужно явно импотировать директивой import:
--import Data.Char

-- Здесь Char - имя самого модуля, то есть это файл Char.hs, а все, что написано
-- до него, повторяет структуру директории. В данном случае модуль стандартный,
-- поэтому он просто подтянется.

-- Импорты должны ставять в начале файла, после объявления текущего модуля.

-- Директива import импортирует все те функции и типы из модуля Char, которые
-- в модуле объялвены публичными. Например, функция toLower :: Char -> Char.

-- Иногда мы не хотим засорять все пространство имен всеми функциями из модуля.
-- Или даже просто хотим избежать коллизий. Тогда можно указать явно, какие
-- функции импортировать:
--import Data.Char (toUpper)
-- Если несколько, то через запятую.

-- Для обратного эффекта есть ключевое слово:
--import Data.Char hiding (toLower)

-- Иногда использование hiding не решает конфликты имен. Например, если в разных
-- модулях есть две функции с одинаковым именем, а нам нужны обе. В этом случае
--import Data.List
--import Data.Set

-- В каждом модуле есть функция union, и тогда при ее вызове произойдет ошибка:
-- компилятор скажет, что имя разрешается неоднозначно. В таком случае можно
-- использовать полное имя функций:
--unionList = Data.List.union
--unionSet = Data.Set.union

-- Если одна из функций нужна часто, а из другого редко, это может быть все
-- равно неудобно. Поэтому можно для импорта потребовать указания полного имени.
--import qualified Data.List

-- Наконец, из-за вложенности папок, имя модуля может быть достаточно длинным,
-- поэтому можно дать модулю псевдоним:
--import Data.Char as C
-- При этом все еще можно обращаться к функциям через Data.Char.

-- Все вместе:
--import qualified Data.Char as C hiding (toLower)

-- С помощью hiding можно скрывать некоторые функции из Prelude,
-- который импортируется неявно. Так мы можем определить функции с тем же именем.
--import Prelude hiding (max)

-- Каждый импорт только добавляет новые имена, поэтому hiding импортированного
-- имени не дает никакого эффекта. В том числе если начала написать import
-- Prelude, а затем import Prelude hiding (max), то фукнция max все равно
-- будет видна.

--------------------------------------------------------------------------------
-- ЭКСПОРТЫ

-- По умолчанию экспортируются все top level имена, объявленные в модуле, однако
-- это поведение можно поменять.
--module Seminar06 (four, five) where

-- В таком случае при импорте модуля Seminar06 будут доступны только константы
-- four и five.

-- Замечание: отношение импорт-экспорт не транзитивно. То есть если модуль C
-- импортирует модуль B, а модуль B импортирует модуль A, то в модуле C
-- содержание модуля A без явного импорта не будет доступно.

-- Явный экспорт является единственным способом инкапсуляции в Haskell. Ранее
-- рассмотренные выражения let..in и конструкцию where, но они не подходят,
-- когда вспомогательную функцию нужно использовать как часть реализации
-- нескольких верхнеуровневых функций. В этом случае поможет только явное
-- экспортирование имен из модуля.
