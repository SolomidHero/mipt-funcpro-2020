# Рекомендации по написанию кода

## Синтаксис

1. В Haskell, Scala и F# принят camelCase, в Lisp - lisp-case. В случае camelCase чаще всего функции пишут с маленькой буквы (кроме конструкторов типов и активных шаблонов), а типы с большой.
1. Не забывайте пробелы вокруг бинарных операторов, внутри конструкторов списка и между функцией и аргументами.
1. Старайтесь не писать скобки, если их можно опустить.
1. Не нужно указывать типы функций, если код и так компилируется (для F#): лучше написать такой код и дать переменным такие имена, чтобы тип легко считывался программистами. Синтаксически в F# типы сильно перегружают код и скорее усложняют его чтение.
1. Не нужно указывать типы .NET-стиле: например, вместо `List<'a>` или `list<'a>` лучше писать `'a list`. Допустимые исключения: `Lazy<'t>`.

## Лаконичность

1. Не оставляйте выражения, которые можно вычислить тривиально: `result && true`, `result && false`, `if cond then true else false` и так далее.
1. Не забывайте, что паттерн-матчинг по последнему аргументу функции можно переписать через `function` и что в паттерн-матчинге есть guard'ы (условия `when`).
1. Если часть шаблона не используется, заменяйте ее на символ `_`. Кроме того, рекомендую подбирать имена для шаблонов-констант таким образом, чтобы они не перекрывали имена аргументов функций (добавляйте штрих `'`). Если же вы, скажем, сопоставляете `n` c `n`, то можно заменить шаблон на `_`, а в правой части использовать `n` из аргументов.
1. Нередко встречается такая конструкция: объявление списка, затем новая константа, где к этому списку применили какую-то одну функцию и так далее. Вместо это лучше реализовать то же самое в виде конвейера: передавать список в одну функцию, затем сразу же результат в третью и так далее. Но здесь нужно следить за балансом: каждая из функций должна быть достаточно простой, чтобы код легко считывался. Если этого не происходит - нужны константы с понятными именами для промежуточных вычислений.

## Эффективность

1. Старайтесь не использовать в рекурсии конкатенацию списков, если второй список имеет константную длину (чаще всего это один элеимент). Конкатенация работает за линию от длины первого списка, значит, вы получаете потенциальный квадрат в асимптотике. Проще добавлять элементы в начало списка, а в конце сделать за линию разворот списка.
1. Вместо `List.item 0` лучше писать `List.head`. Первый вариант формально имеет линейную сложность, второй - константную (и он компактнее и идейно более правильный). Поэтому при беглом анализе асимптотики выгоднее использовать `List.head`.
1. Каждый раз при написании рекурсивной функции подумайте, получилась ли рекурсия хвостовой и можно ли ее такой сделать. Если можно, то лучше сделать.

## Архитектура

1. Функция, объявленная во внешней области видимости, доступна при импорте всем пользователям. Поэтому если у нее среди аргументов есть аккумулятор, пользователю придется угадывать, как функция реализована, чтобы подставить правильное значение в этот аргумент. Аккуратнее будет написать вложенную функцию, которая имеет аккумуляторы, а во внешней оставить только полезные для интерфейса аргументы и вызов функции-реализации.
1. Не пишите излишне абстрактный код. Каждая функция должна иметь конкретную задачу: как-то обработать коллекцию, что-то посчитать и так далее. Пример плохой функции: `forLoop` с семинара. По ней функции непонятно, как ей пользоваться, она больше похожа на синтаксическую конструкцию языка, чем на собственно функцию (так и была придумана: показать, как делать циклы).
