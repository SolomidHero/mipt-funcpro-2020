// -----------------------------------------------------------------------------
// АКТИВНЫЕ ШАБЛОНЫ

// На прошлом семинаре мы рассматривали ленивые последовательности, позволяющие
// нам иметь бесконечную последовательность однотипных элементов. К сожалению,
// у ленивых последовательностей в F# есть один колоссальный недостаток: для них
// нельзя делать паттерн-матчинг. То есть если мы захотим рекурсивно обходить
// последовательность, нам придется писать конструкции вида
let rec seqSum xs =
    if Seq.isEmpty xs then 0
    else Seq.head xs + seqSum (Seq.tail xs)

// К счастью, не все потеряно! В F# возможно реализовать собственные шаблоны для
// паттерн-матчинга. Этот инструмент носит название активные шаблоны

// Активные шаблоны - это произвольные функции, которые выполняются в контексте
// сопоставление с образцом. Сначала перечисляются все варианты сопоставления
let ( |Nil|Cons| ) xs =
    if Seq.isEmpty xs then Nil
    else Cons (Seq.head xs, Seq.tail xs)

// Теперь можно написать, например, так
let findSecond = function
| Nil -> None
| Cons (_, Nil) -> None
| Cons (_, Cons(x, _)) -> Some x // Запись избыточна, это лишь демонстрация

// -----------------------------------------------------------------------------
// ПРАВАЯ СВЕРТКА

// При обходе списков часто реализуется одна и та же схема рекурсии: если список
// пустой, то возвращается некоторое начальное значение, а если список непустой,
// то результат применения функции к голову списку и рекурсивному вызову на
// хвосте списка. Например, так вычисляется длина списка, сумма, произведение
// элементов
let rec length = function
| Nil -> 0
| Cons (_, xs) -> 1 + length xs
let rec sum = function
| Nil -> 0
| Cons (x, xs) -> x + sum xs
let rec prod = function
| Nil -> 1
| Cons (x, xs) -> x * prod xs

// Все эти функции можно выразить через функцию правой свертки (будет еще левая)
let rec foldRight f init = function
| Nil -> init
| Cons (x, xs) -> f x (foldRight f init xs)
// По смыслу init - значение на пустом списке, а f - это способ комбинировать
// элемент смысла и все остальные

// Обратите внимание на типы: пусть элементы списка имеют тип 'a, а возвращаемое
// значение - 'b. Тогда однозначно определяются типы init и  f:
// init : 'b
// f : 'a -> 'b -> 'b

// Как теперь выражаются наши функции
let length' xs = foldRight (fun _ b -> 1 + b) 0 xs
let sum' xs = foldRight ( + ) 0 xs
let prod' xs = foldRight ( * ) 1 xs

// Свертка называется правой, потому что если представить, что f - это
// правоассоциативный оператор o, то результат работы функции представим в виде
// (x1 o (x2 o ... o (xN o init)...))
// Здесь o - однозначно правоассоциативен, потому что в противном случае
// не будут соблюдены типы

// Чтобы в этом убедиться, рассмотрим неассоциативный оператор
let three = foldRight ( - ) 0 [ 1; 2; 3; 4; 5 ]
// 1 - (2 - (3 - (4 - (5 - 0)))) = 1 - (2 - (3 + 1)) = 1 + 2

// Любопытно, что сам список можно записать в виде свертки
// Действительно, получается, что
// foldRight ( :: ) [] xs = x1 :: x2 :: ... :: xN :: [] = xs
// Получается, мы получили как будто конструктор списка, но с произвольной
// операцией между головой и хвостом, а не добавлением в начало списка

// -----------------------------------------------------------------------------
// ЛЕВАЯ СВЕРТКА

// Симметрично можно рассмотреть левую свертку: для этого рассмотрим выражение,
// но начальное значение применяется слева
// (...((init o x1) o x2) o ... o xN)

// При этом отличается тип оператора o (или функции f). Если, как и раньше,
// элемент списка имеет тип 'a, а тип результата - 'b, то оставшиеся типы
// init : 'b
// f : 'b -> 'a -> 'b

let rec foldLeft f init = function
| Nil -> init
| Cons (x, xs) -> foldLeft f (f init x) xs

// Мнемоническое правило, как отличить левую свертку от правой: в правой свертке
// у оператора тип правой свертки такой же, как результат, а у левой - левый

// Обратите внимание, что функция foldLeft реализована через хвостовую рекурсию

// -----------------------------------------------------------------------------
// БЕСКОНЕЧНЫЕ СВЕРТКИ

// Правая и левая свертки по-разному работают на бесконечных списках.
// Рассмотрим правую свертку. Первый вопрос, который возникает, - это
// останавливается ли когда-либо вычисление на бесконечной последовательности?

// Оказывается, нет: в выражении f x (foldRight f init xs) сначала произойдет
// рекурсивный вызов в скобках, затем он развернется в такое же выражение
// (обязательно, потому что список бесконечный), затем еще раз и так далее
// foldRight ( && ) true (Seq.initInfinite (( <> ) 100)) // Не работает

// Виной всему энергичная модель вычислений! Поэтому, чтобы реализовать правую
// свертку на бесконечных списках, придется добавить немного ленивости:
let rec foldRightLazy f (init : Lazy<'b>) = function
| Nil -> init.Force ()
| Cons (x, xs) -> f x (lazy (foldRightLazy f init xs))

let andLazy x (y : Lazy<bool>) = x && y.Force ()
foldRightLazy andLazy (lazy true) (Seq.initInfinite (( <> ) 100))

// Что касается левой свертки, то она реализована через хвостовую рекурсию,
// а значит, каждый вызов foldLeft раскрывается в еще одну левую свертку
// (потому что терминальное условие не достигается). Таким образом, левая
// свертка также не завершается

// Также стоит заметить, что, в отличие от правой свертки, добавление ленивости
// в левую принесет только вред: если начальное значение будет ленивым, то тогда
// при вычислении будет скапливаться большое невычисленное выражение, что может
// замедлить работу программы

// -----------------------------------------------------------------------------
// ОБРАТНЫЕ СВЕРТКИ

// Если вы запомните только типы сверток согласно мнемоническому правилу,
// то у вы можете не подумать и реализовать свертки неправильно

// Рассмотрим следующую функцию. В чем ее отличие от foldLeft?
let rec foldRightBack f init = function
| Nil -> init
| Cons (x, xs) -> foldRightBack f (f x init) xs
// Запишем выражение в операторном виде
//   foldRightBack o init             [ x1; x2; ... ; xN ] =
// = foldRightBack o (x1 o init)      [ x2; ... ; xN ]     =
// = foldRightBack o (x2 o x1 o init) [ ...; xN ]          =
// = ...                                                   =
// = xN o ... o x2 o x1 o init

// Получили свертку в обратную сторону. Ее эквивалент по значениям -
// foldRight f init (Seq.rev xs). Это в общем случае не равно
// foldRight f init xs, поскольку список обходится в обратную сторону

// Симметрично рассмотрим левую обратную свертку
let rec foldLeftBack f init = function
| Nil -> init
| Cons (x, xs) -> f (foldLeftBack f init xs) x
// Это выражение эквивалентно init o xN o ... o x2 o x1

// Его ленивая версия выглядит так
let rec foldLeftBackLazy f (init : Lazy<'b>) = function
| Nil -> init.Force ()
| Cons (x, xs) -> f (lazy (foldLeftBackLazy f init xs)) x

// В отличие от ленивой прямой правой свертки, эта свертка
// все равно не завершается на бесконечных списках: для этого ей нужно получить
// последний элемент
let andBackLazy (x : Lazy<bool>) y = x.Force () && y
// foldLeftBackLazy andBackLazy (lazy true) (Seq.initInfinite (( <> ) 100))

// -----------------------------------------------------------------------------
// ФУНКЦИИ REDUCE

// При использовании сверток можно заметить, что часто результат свертки на
// одноэлементном списке - это тот самый элемент. Поэтому реализованы еще
// функции reduceLeft и reduceRight, которые не принимают начальное значение.
// На непустых списках они вернут свертку хвоста с начальным значением -
// головой, а на пустых бросят исключение. Бросать исключения не очень хорошо,
// поэтому реализуем через option
let reduceRightOption f = function
| Nil -> None
| Cons (x, xs) -> Some (foldRight f x xs)
let reduceLeftOption f = function
| Nil -> None
| Cons (x, xs) -> Some (foldLeft f x xs)
// У обеих функций тип возвращаемого значения (внутри option) совпадает с типом
// элемента списка, что накладывает ограничение на используемый оператор

// -----------------------------------------------------------------------------
// СКАНИРОВАНИЕ

// Иногда требуется получить не только результат свертки всего списка, но и
// все промежуточные вычисления. Для таких случаев пригождается функция
// сканирования

// Начнем с левого сканирования, потому что его реализации намного проще
let rec scanLeft f init = function
| Nil -> Seq.singleton init
| Cons (x, xs) -> seq { yield init; yield! scanLeft f (f init x) xs }
// Результат в операторном виде записывает так:
// [ init; init o x1; ...; init o x1 o ... o xN ]

let partialSums xs = scanLeft ( + ) 0 xs

// Интересно, что в отличие от левой свертки, левое сканирование умеет работать
// с бесконечными списками, поскольку конструирует результаты, отщепляя элемент
// за элементом. Правда, для этого придется добавить ленивости
let factorials = scanLeft ( * ) 1 (Seq.initInfinite (fun i -> i + 1))

// Правое сканирование устроено несколько сложнее
let rec scanRight f init = function
| Nil -> Seq.singleton init
| Cons (x, xs) ->
    let tailFolds = scanRight f init xs
    seq {
        yield f x (Seq.head tailFolds)
        yield! tailFolds
    }
// Получаем [ x1 o ... o xN o init; ...; xN o init; init ]

// Правое сканирование с бесконечными списками уже не работает

// -----------------------------------------------------------------------------
// РАЗВЕРТКИ

// Задача свертки - свернуть список и вернуть некоторое значение. Обратная
// задача - взять некоторое значение и по функции сгенерировать список
// результатов. Для решения таких задач предназначены функции развертки

// Первое, что нужно сделать, - определить тип такой функции. Сделаем это
// пошагово
// 1. Результат - это 'b seq, начальное значение - 'a, и нужна функция. Какой у
// нее тип?
// 2. В качестве аргумента ей нужно принимать 'a, потому что это единственное,
// что нам дано. Что она должна возвращать?
// 3. Если она будет возвращать просто 'b, который мы добавим в ответ, то в
// результрующем списке все элементы будут одинаковые. Поэтому вернем пару
// 'b * 'a, где второй элемент - это новое значение для функции.
// 4. Наконец, если реализовать такую функцию, то мы получим бесконечный список.
// Чтобы обобщить функцию и возвращать в том числе и конечные списки, тип
// результата f будет ('b * 'a) option. Если функция вернула None, то список
// построен, а если нет, то продолжим дальше
let rec unfoldRight f init =
    let unfoldRight' = function
    | None -> Seq.empty
    | Some (x, init') -> seq { yield x; yield! unfoldRight f init' }
    unfoldRight' (f init)

// Если разверточная функция всегда возвращает Some, то список бесконечный

// Напишем функцию iterate, которая по функции и списку возвращает
// [ init; f init; f (f init); ... ]
let iterate f = unfoldRight (fun x -> Some (x, f x))

// Аналогично реализуется левая развертка
let rec unfoldLeft f init =
    let unfoldLeft' = function
    | None -> Seq.empty
    | Some (init', x) -> seq { yield! unfoldLeft f init'; yield x }
    unfoldLeft' (f init)

// Работает только с конечными списками
let iterate' f = unfoldLeft (fun x -> Some (f x, x)) // Лучше не вызывать
let iterateLeft f = unfoldLeft (function
    | x when x < 100 -> Some (f x, x)
    | _ -> None)

// В целом, функция бесполезна, потому что голова вычисляется энергично, значит
// все равно придется проделать энергично рекурсивные вызовы
