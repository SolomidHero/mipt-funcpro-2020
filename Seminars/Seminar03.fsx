// -----------------------------------------------------------------------------
// ОБЪЯВЛЕНИЯ ТИПОВ

// В F# новые типы создаются с помощью ключевого слова type. Самое примитивное,
// что можно сделать, - это сделать алиас к существующему типу
type MyInt = int

// Теперь есть новый тип MyInt, причем MyInt и int - абсолютно равнозначные
// типы, для них не трубется преобразования
let threeMyInt : MyInt = 3 : int
let threeInt : int = threeMyInt : MyInt

// -----------------------------------------------------------------------------
// АЛГЕБРАИЧЕСКИЕ ТИПЫ ДАННЫХ

// Перейдем к более сложной конструкции - это алгебраические типы данных. В F#
// их также называют размеченными объединениями

// Алгебраические типы данных - это тип сумм произведений. Математически, если
// типы представить как множества, то алгебраический тип данных - это
// дизъюнктное объединение декартовых произведений других типов

// Начнем строить их постепенно, с самого простого примера - создаем новый тип
// из одного значения
type NewType = NewType
// Здесь NewType слева - это тип данных, а NewType справа - конструктор типа.
// Мы можем объявить значение типа NewType с помощью конструктора NewType.
// Конфликта имен не происходит, так как имена типов и имена конструкторов
// живут в разных пространствах имен
let newType : NewType = NewType // Обратите внимание на подсветку синтаксиса

// Если очень хочется, можно дать конструктору типа и самому типу разные имена
type NewType1 = NewType2 // Но так никто не делает, так что лучше не надо

// Идем дальше: можно объявлять тип из нескольких значений. По смыслу это
// перечисление. Элементы перечисления называются случаями
type Enumeration = Value1 | Value2 | Value3
// Здесь Enumeration - имя типа, а Value1, Value2, Value3 - конструкторы типа.
// Значения объявляются точно так же
let value2 : Enumeration = Value2

// Следующий шаг на пути к полноценным алгебраическим типам данных - создавать
// новый тип на основе имеющегося
type IntWrapper = IntWrapper of int
// Здесь аналогично IntWrapper слева - тип, а IntWrapper справа - конструктор
// типа. Отличие конструкторов, рассмотренных ранее, в том, что конструктор
// IntWrapper имеет аргумент типа int, указанный после слова of. В отличие от
// алиасов, int и IntWrapper - разные типы
let wrappedInt : IntWrapper = IntWrapper 2902
// По сути для конструкции type <TypeName> = <CtorName> of <Type> конструктор -
// это функция <CtorName> : <Type> -> <TypeName>. Преобразование типа в int
// работать не будет:
// let sourceInt : int = int wrappedInt // Не работает

// В качестве типа можно брать любой имеющийся тип, например, кортеж
type TupleWrapper = TupleWrapper of int * string

let wrappedTuple : TupleWrapper = TupleWrapper (29, "feb")

// Наконец, можно брать перечисление даже с такими типами
type TypedEnumeration =
| StringWrapper of string // Здесь | можно не писать, просто для красоты
| UnitWrapper of unit

// У этих констант одинаковый тип
let wrappedString : TypedEnumeration = StringWrapper "string"
let wrappedUnit : TypedEnumeration = UnitWrapper ()

// Таким образом, если мы хотим создать алгебраический тип данных, например,
// int * string + char * float * float + int, то его можно объявить так
type UselessType =
| IntString of int * string
| CharFloatFloat of char * float * float
| Int of int
// Естественно, лучше давать конструкторам и типу разумные имена, в зависимости
// от того, для чего мы собираемся использовать тип

// -----------------------------------------------------------------------------
// СОПОСТАВЛЕНИЕ С ОБРАЗЦОМ

// Основное преимущество алгебраических типов данных - для них преркасно
// работает сопоставление с образцом
let doSmth = function
| IntString (x, s) -> printfn "%A %A" x s
| CharFloatFloat (c, f1, f2) -> printfn "%A %A %A" c f1 f2
| Int x -> printfn "%A" x

doSmth <| IntString (29, "feb")
doSmth <| CharFloatFloat ('a', 3.5, 2.0)
doSmth <| Int 2020

// -----------------------------------------------------------------------------
// ПОЛИМОРФНЫЕ ТИПЫ

// Кроме того, типы можно делать полиморфными. Для этого перед (!) именем типа
// нужно написать имя типа-параметра. В F# обычно типы-параметры именуют с '.
// После этого в каждом из случаев можно использовать параметр как обычный тип
type 't PolymorphicType =
| FirstCase of int
| SecondCase of int * 't

// Параметров может быть несколько. Правда, для этого потребуется другой
// синтаксис, унаследованный от C# (он доступен и для типов с одним параметром,
// но это выглядит недостаточно по-хипстерски и потому не рекомендуется)
type PolyPolymorphicType<'a, 'b, 'c> =
| CaseAB of 'a * 'b
| CaseBC of 'b * 'c
| CaseCA of 'c * 'a

let ppValue : PolyPolymorphicType<bool, char, int> = CaseBC (' ', 4)

// -----------------------------------------------------------------------------
// РЕКУРСИВНЫЕ ТИПЫ

// В определении типа допускается использование рекурсии
type 't Tree =
| Leaf of 't
| Node of 't Tree * 't Tree

// Создаем дерево
let tree = Node (Node (Leaf 1, Node (Leaf 0, Leaf 5)), Leaf 4)

// Посчитаем теперь высоту и размер дерева
let rec height = function
| Leaf _ -> 0
| Node (l, r) -> 1 + max (height l) (height r)

let rec size = function
| Leaf _ -> 1
| Node (l, r) -> 1 + size l + size r

// Разумеется, как и во всякой рекурсии, должен быть терминальный случай,
// иначе мы не сможем создать значение типа
type Loop = Loop of Loop // Корректное объявление типа
// let loop : Loop = Loop <| Loop <| ... // Объявить значение невозможно

// Как получить значение
let rec loop () : Loop = Loop <| loop ()

// Более того, типы могут быть взаимно-рекурсивными, то есть можно объявить
// сразу несколько типов, каждый из которых использует другой тип. Синтаксически
// зависимость между типами обозначается словом and вместо type у второго типа
type 't Cell' =
| NilCell'
| ConsCell' of 't * 't Stream' 
and 'u Stream' = 'u Cell'
// Заметье, что в этом примере второй тип - это всего лишь алиас, но в общем
// случае он может быть намного сложнее

// Чуть позднее, с небольшой модификацией мы увидим, где это нужно

// -----------------------------------------------------------------------------
// ПРИМЕРЫ АЛГЕБРАИЧЕСКИХ ТИПОВ

// Алгебраические типы данных используются повсеместно для моделирования
// предметной области. Например, так можно задать человека как его ФИО, дата
// рождения и так далее (декартово произведение строчек, даты и так далее)

// Более того, некоторые типы из уже известных нам - алгебраические. Например,
// опциональный тип или список. Завелосипедим их
type 't Option' =
| None'
| Some' of 't

// Проверим на пустоту
let isEmpty = function
| None' -> true
| _ -> false

printfn "%A" <| isEmpty None'
printfn "%A" <| isEmpty (Some' 4)

type 't List' =
| Nil'
| Cons' of 't * 't List'

// Посчитаем длину такого списка
let rec length = function
| Nil' -> 0
| Cons' (_, xs) -> 1 + length xs

printfn "%A" <| length (Cons' (4, Cons' (3, Cons' (2, Cons' (1, Nil')))))

// -----------------------------------------------------------------------------
// ЛЕНИВЫЕ ВЫЧИСЛЕНИЯ

// В F# используется энергичная стратегия вычисления, то есть все аргументы
// функций высисляются до применения функции к этим аргументам. Это оправдано,
// поскольку требуется прозрачное взаимодействие с .NET Framework и
// компонентами, написанных на других языках платформы. Например, мы видели, что
// printfn реализована на C#

// Тем не менее, в F# есть механизм, позволяющий выполнять вычисления лениво.
// Для этого используется тип Lazy<'t>, объекты которого можно создать с помощью
// ключевого слова lazy
let lazyFour : Lazy<int> = lazy 4
let lazy2Plus2 : Lazy<int> = lazy (2 + 2)
// На всякий случай: Lazy не алгебраический тип данных, а lazy не конструктор

// Внутри себя объект типа Lazy<'t> содержит значение типа 't в некоторой
// невычислененной форме. Чтобы вычислить выражение, получив значение типа 't,
// используется метод Force
let four : int = lazyFour.Force ()
// Обратите внимание, что Force - это метод, а не поле, и его передают аргумент
// (). Этот метод вычисляет значение внутреннего выражения и возвращает его

// Последующие вызовы Force не приводят к повторному вычислению выражения:
// результат сохраняется. Это называется мемоизацией. Как это проверить
let lazyUnit = lazy (printfn "printed")
lazyUnit.Force () // Печатает printed
lazyUnit.Force () // Нет вывода
lazyUnit.Force () // Нет вывода

// С помощью ленивых вычислений можно реализовать ленивые последовательности
type 't Cell =
| NilCell
| ConsCell of 't * 't Stream 
and 't Stream = Lazy<'t Cell>

let lazySeq : int Stream = lazy (ConsCell (1, lazy NilCell))

// Чтобы с ними работать, нужно каждый раз форсировать вычисление. Например,
// конкатенация таких последовательностей
let rec concat (xs : 't Stream) (ys : 't Stream) : 't Stream =
    match xs.Force () with
    | NilCell -> ys
    | ConsCell (x, zs) -> lazy (ConsCell (x, concat zs ys))

// -----------------------------------------------------------------------------
// ЛЕНИВЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ
    
// Работать с lazy и Force не очень удобно, но ленивые последовательности на
// самом деле очень удобны. Они используются, когда требуется большая
// упорядоченная коллекция элеменетов, при этом не обязательно все их них
// будут использованы

// Разумеется, в F# есть реализованные ленивые последовательности.
// Последовательность - это упорядоченный набор данных одного типа, при этом
// элементы последовательности вычисляются по требованию. По этой причине
// последовательности могут быть эффективнее списков, когда используются не все
// элементы

// Обозначается этот тип 't seq. Он полиморфный. Функция для работы с
// последовательностями лежат в модуле Seq
let empty = Seq.empty
let ten = seq { 1 .. 10 }
let oddTen = seq { 1 .. 2 .. 20 }
let elems = seq [ 1; 2; 3 ]
let yields = seq { yield 1; yield 2; yield 3 }
let seq123Yield = seq {
    yield 1
    yield 2
    yield 3
}
let forYield = seq { for i in 1 .. 10 do yield i * i }
let forArrow = seq { for i in 1 .. 10 -> i * i }
let evenNumbers = Seq.init 1000000001 (fun n -> n * 2)

// В целом, здесь все то же самое, что и со списками, только вместо квадратных
// скобок фигурные. Новая возможность - это встроить последовательность в другую
// последовательность. Это делается с помощью yield! (с восклицательным знаком)
let concattedSeq = seq {
    yield 1
    yield! oddTen
    yield! yields
} // 1 1 3 5 7 9 11 13 15 17 19 1 2 3

// Функции для работы с последовательностями во многом повторяют функции для
// работы со списками. Но некоторые недоступны, например, unzip и partition.
// Кроме того, в функции из модуля Seq можно передавать обычные списки, и на
// выходе будут последовательности

// Рассмотрим функции, полезные для работы с последовательностями
printfn "%A" (Seq.takeWhile (fun x -> x % 2 = 0) [ 1; 2; 3 ])
printfn "%A" (Seq.skipWhile (fun x -> x % 2 = 0) [ 1; 2; 3 ])
printfn "%A" (Seq.take 2 [ 1; 2; 3 ])
printfn "%A" (Seq.truncate 4 [ 1; 2; 3 ]) // Нет ошибки, если берем больше
printfn "%A" (Seq.skip 2 [ 1; 2; 3 ])

// Чтобы получить из списка последовательность, используется функция Seq.ofList.
// В обратную сторону, соответственно, List.ofSeq

// Рассмотрим отдельно функцию initInfinite. Она принимает функцию f : int -> 't
// и возвращает последовательность типа 't seq, где на i-м месте находится
// элемент f i (индексация с нуля)
printfn "%A" (Seq.initInfinite (fun i -> i)) // 0 1 2 3 ...

// Эта последовательность бесконечная (!). Так как элементы вычисляются по
// требованию, то ни один элемент изначально не вычислен, и в памяти можно
// хранить только одну лишь функцию. Убедимся, что элементы не вычисляются
let units = Seq.initInfinite (printfn "%A") // Нет вывода
let threeUnits = Seq.take 3 units // И даже так

// Одно из полезных применений последовательностей - это чтение из файла. Если
// считать сразу весь файл в список, то памяти может не хватить, однако если
// читать в последовательность, то мы не будем хранить то, что еще не нужно,
// а то, чем уже попользовались, будет очищено сборщиком мусора

// Его как раз удобно делать с помощью Seq.initInfinite. Например, можно
// воспользоваться такой реализацией для ввода с консоли
let readLines () =
    Seq.initInfinite (fun _ -> System.Console.ReadLine ())
    |> Seq.takeWhile (fun line -> line <> null)
// Когда строки файла закончились, возвращается null (это C#, тут
// объекты-ссылки, и ссылки могут быть нулевыми)

// Для работы с файлами на самом деле уже есть удобная функция
let thisFile = System.IO.File.ReadLines "Seminar03.fsx"
// В документации здесь говорится, что возвращается IEnumerable<string> из C#.
// Но 't seq в F# - это как раз алиас для типа IEnumerable<'t>
printfn "%A" <| (Seq.take 10 thisFile |> List.ofSeq)

// -----------------------------------------------------------------------------
// КОРЕКУРСИЯ

// Ленивые последовательности позволяют экономит память, поскольку не вычисляют
// элементы, которые не были использованы. В функциональном программировании
// это особенно важно, поскольку неизбежно возникает рекурсия для обходов
// разных структуры или генерации данных

// Оказывается, иногда вместо записи рекурсивных функций можно написать
// последовательность, которая выдает элементы. Например, так можно записать
// факториал или список натуральных чисел. Этот прием называется корекурсией
let rec nats = seq {
    yield 0
    yield! Seq.map (( + ) 1 ) nats
} // Обратите внимание: рекурсивная константа. Выдается предупреждение
printfn "%A" <| List.ofSeq (Seq.take 10 nats)

// Рекурсия здесь выглядела бы так
let rec nats' = function
| 0 -> []
| n -> n :: nats' (n - 1)

// Такой прием называется корекурсией, поскольку он в некотором смысле
// двойственнен к рекурсии. Корекурсия берет начальное значение значение и
// создает на его основе дальнейшую последовательность (она может быть
// бесконечной). Рекурсия берет какие-то данные, анализирует их, то есть
// разделяет на части, делает вычисление для частей и потом комбинирует это
// в итоговый результат. Получается конечная структура данных.

// Идейная составляющая не очень понятно, здесь стоило бы углубиться в теорию
// категорий, рассказать про коданные и прочее... Детская и не вполне корректная
// аналогия из алгоритмов - динамика вперед (корекурсия) и назад (рекурсия)

// -----------------------------------------------------------------------------
// ХВОСТОВАЯ РЕКУРСИЯ

// Но все же корекурсия - не очень удобный инструмент, многие вещи делаются
// рекурсивно, а это, как мы знаем из императивного программирования, не очень
// эффективно из-за большого стека. Самое неприятное, что даже для простых
// вещей, которые в императивном программированию делаются циклами, в
// функциональном приходится использовать рекурсию, а значит, возникает расход
// памяти. Рассмотрим, например, функцию вычисления длины списка
let rec length' = function
| [] -> 0
| _ :: xs -> 1 + (length' xs)

// На каждом уровне рекурсии потребуется хранить адрес возврата, аргументы и
// возвращаемый результат, то есть всего нужно хранить O(n) ячеек памяти. А на
// императивном языке программирования можно обойтись константой, написав цикл

// К счастью, компилятор умеет оптимизировать рекурсивные функции, если они
// реализованы при помощи хвостовой рекурсии. Рекурсия называется хвостовой,
// если при вычислении выражения рекурсивный вызов либо отсутствует, либо
// он единственный и является последней операцией

// В функции length' после рекурсивного вызова применяется оператор ( + ),
// поэтому она не хвосто-рекурсивная. Вот исправленная версия
let lengthTailRec list =
    let rec length' acc = function
    | [] -> acc
    | _ :: xs -> length' (acc + 1) xs
    length' 0 list

// Использование аккумулятора - стандартный прием превращения рекурсии в
// хвостовую

// -----------------------------------------------------------------------------
// ВЫЧИСЛЕНИЯ С ПРОДОЛЖЕНИЯМИ

// К сожалению, не всегда возможно просто так взять и свести рекурсию к
// хвостовой. Например, если рекурсивных вызовов несколько, то никакой
// бездумный аккумулятор-счетчик не поможет

// Вспомним функцию вычисления размера дерева
let rec size' = function
| Leaf _ -> 1
| Node (l, r) -> 1 + size' l + size' r

let rec size'' acc = function
| Leaf _ -> 1 + acc
| Node (l, r) -> size'' (size'' (1 + acc) l) r // Не получилось :(

// В этом случае можно попробовать вместо того, чтобы аккумулировать ответ,
// аккумулировать оставшиеся рекурсивные вызовы (в общем случае - просто
// вычисления). Этот прием называется вычисления с продолжениями
let sizeTailRec tree =
    // Аккумулятор - это функция из int -> int. Она принимает результат текущего
    // вычисления и возвращает сумму из результата текущего вычисления и
    // оставшегося рекурсивного вызова. Продолжения накапливаются в обратном
    // порядке, то есть начальное значение продолжения - это последнее,
    // что будет вычислено. Поэтому начальное значение - id
    let rec size t cont =
        match t with
        | Leaf _ ->
            // Здесь нам вычислять нечего: ответ 1, так что сразу передаем его
            // в продлолжение. Оно воспользуется нашим ответом, чтобы считать
            // дальше
            cont 1
        | Node (l, r) ->
            size l (fun sizeL -> // После вычисления размера l имеем sizeL
                size r (fun sizeR -> // И вычисляем размер R, получая sizeR
                    cont (1 + sizeL + sizeR))) // Наконец, все складываем
    size tree (fun x -> x) // Вот теперь получилось
